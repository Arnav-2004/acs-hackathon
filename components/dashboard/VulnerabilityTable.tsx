import React, { useMemo, useEffect, useState } from "react";
import { View, Text, StyleSheet, ScrollView, ActivityIndicator } from "react-native";
import {
  useFonts,
  Inter_600SemiBold,
  Inter_500Medium,
  Inter_400Regular,
} from "@expo-google-fonts/inter";

// Type definition for CVE data
interface CVE {
  cveid: string;
  epssscore: string;
  maxcvss: string;
  publisheddate: string;
  source: string;
  summary: string;
  updateddate: string;
}

// Type definitions for API responses
interface TypeData {
  [year: string]: {
    [vulnerabilityType: string]: string | number;
  };
}

interface ImpactData {
  [year: string]: {
    [impactType: string]: string | number;
  };
}

interface VulnerabilityTablesProps {
  cves?: CVE[];
  // Adding an optional prop to allow manual data fetching control
  manualFetch?: boolean;
}

export const VulnerabilityTables = ({ cves: propCves, manualFetch = false }: VulnerabilityTablesProps) => {
  const [fontsLoaded] = useFonts({
    Inter_600SemiBold,
    Inter_500Medium,
    Inter_400Regular,
  });

  // State to store fetched CVE data
  const [fetchedCves, setFetchedCves] = useState<CVE[]>([]);
  // State for direct API data
  const [vulnerabilityTypeData, setVulnerabilityTypeData] = useState<TypeData | null>(null);
  const [impactTypeData, setImpactTypeData] = useState<ImpactData | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Combine prop data with fetched data for processing
  const cves = propCves || fetchedCves;

  // Define vulnerability and impact types
  const vulnerabilityTypes = [
    { name: "Overflow", keywords: ["overflow", "buffer overflow", "stack overflow", "heap overflow"] },
    { name: "Memory Corruption", keywords: ["memory corruption", "memory safety"] },
    { name: "Sql Injection", keywords: ["sql injection", "sqli"] },
    { name: "XSS", keywords: ["xss", "cross site scripting", "cross-site scripting"] },
    { name: "Directory Traversal", keywords: ["directory traversal", "path traversal"] },
    { name: "File Inclusion", keywords: ["file inclusion", "include file", "rfi", "lfi"] },
    { name: "CSRF", keywords: ["csrf", "cross site request forgery", "cross-site request forgery"] },
    { name: "XXE", keywords: ["xxe", "xml external entity"] },
    { name: "SSRF", keywords: ["ssrf", "server side request forgery", "server-side request forgery"] },
    { name: "Open Redirect", keywords: ["open redirect", "unvalidated redirect"] },
    { name: "Input Validation", keywords: ["input validation", "improper validation", "insufficient validation"] },
  ];

  const impactTypes = [
    {
      name: "Code Execution",
      keywords: [
        "execute code",
        "code execution",
        "arbitrary code",
        "remote code execution",
        "rce",
      ],
    },
    { name: "Bypass", keywords: ["bypass", "circumvent"] },
    {
      name: "Privilege Escalation",
      keywords: ["privilege escalation", "gain privilege"],
    },
    {
      name: "Denial of Service",
      keywords: ["denial of service", "dos", "crash"],
    },
    {
      name: "Information Leak",
      keywords: ["information leak", "information disclosure", "data leak"],
    },
  ];

  // Fetch data from API endpoints
  useEffect(() => {
    // Skip fetching if manualFetch is true or if prop data is available
    if (manualFetch || (propCves && propCves.length > 0)) {
      setIsLoading(false);
      return;
    }
    
    async function fetchVulnerabilityData() {
      setIsLoading(true);
      setError(null);
      
      try {
        const endpoints = [
          'https://acs-hackathon-backend.onrender.com/scrape-by-type',
          'https://acs-hackathon-backend.onrender.com/scrape-by-impact-types'
        ];
        
        const [typeResponse, impactResponse] = await Promise.all(
          endpoints.map(url => fetch(url).then(res => {
            if (!res.ok) throw new Error(`API error: ${res.status} for ${url}`);
            return res.json();
          }))
        );
        
        setVulnerabilityTypeData(typeResponse);
        setImpactTypeData(impactResponse);
        setFetchedCves([]);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
        setError(errorMessage);
        console.error('Error fetching vulnerability data:', errorMessage);
      } finally {
        setIsLoading(false);
      }
    }

    fetchVulnerabilityData();
  }, [manualFetch, propCves]);

  // Process the data for tables
  const processedData = useMemo(() => {
    // Process API data if available
    if (vulnerabilityTypeData && impactTypeData) {
      return processApiData(vulnerabilityTypeData, impactTypeData);
    }
    
    // Fallback to CVE-based processing
    if (cves && cves.length > 0) {
      return processCveData(cves);
    }
    
    // Return empty arrays if no data
    return { byType: [], byImpact: [] };
  }, [cves, vulnerabilityTypeData, impactTypeData]);

  // Function to process API data
  function processApiData(typeData: TypeData, impactData: ImpactData) {
    // Get years excluding "Total"
    const typeYears = Object.keys(typeData)
      .filter(year => year !== "Total")
      .sort();
      
    const impactYears = Object.keys(impactData)
      .filter(year => year !== "Total")
      .sort();

    // Process vulnerability type data
    const byTypeArray = typeYears.map(year => {
      const yearData = typeData[year];
      const processedRow = { year };
      
      // Process each vulnerability type
      vulnerabilityTypes.forEach(({ name }) => {
        // Find matching key regardless of case
        const matchingKey = Object.keys(yearData).find(
          key => key.toLowerCase() === name.toLowerCase()
        );
        
        processedRow[name] = matchingKey ? Number(yearData[matchingKey]) : 0;
      });
      
      // Calculate row total
      processedRow['total'] = Object.entries(processedRow)
        .filter(([key]) => key !== 'year')
        .reduce((sum, [, value]) => sum + Number(value), 0);
        
      return processedRow;
    });
    
    // Add total row
    const typeTotal = createTotalRow(byTypeArray, typeData['Total']);
    byTypeArray.push(typeTotal);
    
    // Process impact type data
    const byImpactArray = impactYears.map(year => {
      const yearData = impactData[year];
      const processedRow = { year };
      
      // Process each impact type
      impactTypes.forEach(({ name }) => {
        // Find matching key regardless of case
        const matchingKey = Object.keys(yearData).find(
          key => key.toLowerCase() === name.toLowerCase()
        );
        
        processedRow[name] = matchingKey ? Number(yearData[matchingKey]) : 0;
      });
      
      // Calculate row total
      processedRow['total'] = Object.entries(processedRow)
        .filter(([key]) => key !== 'year')
        .reduce((sum, [, value]) => sum + Number(value), 0);
        
      return processedRow;
    });
    
    // Add total row
    const impactTotal = createTotalRow(byImpactArray, impactData['Total']);
    byImpactArray.push(impactTotal);
    
    return { byType: byTypeArray, byImpact: byImpactArray };
  }
  
  // Helper function to create a "Total" row
  function createTotalRow(dataArray, apiTotalData = null) {
    const totalRow = { year: "Total" };
    
    // If API provides total data, use it
    if (apiTotalData) {
      const typeNames = dataArray[0] ? 
        Object.keys(dataArray[0]).filter(key => key !== 'year' && key !== 'total') : 
        [];
      
      typeNames.forEach(name => {
        // Find matching key in API total data
        const matchingKey = Object.keys(apiTotalData).find(
          key => key.toLowerCase() === name.toLowerCase()
        );
        
        totalRow[name] = matchingKey ? Number(apiTotalData[matchingKey]) : 0;
      });
    } 
    // Otherwise calculate totals
    else {
      const typeNames = dataArray[0] ? 
        Object.keys(dataArray[0]).filter(key => key !== 'year' && key !== 'total') : 
        [];
      
      typeNames.forEach(name => {
        totalRow[name] = dataArray.reduce((sum, row) => sum + (row[name] || 0), 0);
      });
    }
    
    // Calculate grand total
    totalRow['total'] = Object.entries(totalRow)
      .filter(([key]) => key !== 'year')
      .reduce((sum, [, value]) => sum + Number(value), 0);
      
    return totalRow;
  }

  // Function to process CVE data
  function processCveData(cveData: CVE[]) {
    // Extract and sort years
    const years = Array.from(new Set(
      cveData.map(cve => cve.publisheddate.split("-")[0])
    )).sort();
    
    // Initialize data structures
    const byTypeData = initializeDataStructure(years, vulnerabilityTypes);
    const byImpactData = initializeDataStructure(years, impactTypes);
    
    // Process each CVE
    cveData.forEach(cve => {
      const year = cve.publisheddate.split("-")[0];
      if (!years.includes(year)) return;
      
      const summary = cve.summary.toLowerCase();
      
      // Count vulnerability types
      vulnerabilityTypes.forEach(({ name, keywords }) => {
        if (keywords.some(keyword => summary.includes(keyword))) {
          byTypeData[year][name]++;
          byTypeData["Total"][name]++;
        }
      });
      
      // Count impact types
      impactTypes.forEach(({ name, keywords }) => {
        if (keywords.some(keyword => summary.includes(keyword))) {
          byImpactData[year][name]++;
          byImpactData["Total"][name]++;
        }
      });
    });
    
    // Convert to array format with totals
    const byTypeArray = convertToArrayFormat(byTypeData);
    const byImpactArray = convertToArrayFormat(byImpactData);
    
    return { byType: byTypeArray, byImpact: byImpactArray };
  }
  
  // Helper function to initialize data structure
  function initializeDataStructure(years, types) {
    const data = {};
    
    // Initialize for each year
    years.forEach(year => {
      data[year] = types.reduce((acc, { name }) => {
        acc[name] = 0;
        return acc;
      }, {});
    });
    
    // Add Total row
    data["Total"] = types.reduce((acc, { name }) => {
      acc[name] = 0;
      return acc;
    }, {});
    
    return data;
  }
  
  // Helper function to convert object structure to array format
  function convertToArrayFormat(dataObj) {
    return Object.entries(dataObj).map(([year, typeCounts]) => {
      // Calculate row total
      const total = Object.values(typeCounts).reduce((sum, count: any) => sum + count, 0);
      
      return {
        year,
        ...typeCounts,
        total
      };
    });
  }

  // Function to get table cell color based on value
  const getCellColor = (value: number, max: number) => {
    if (value === 0) return "#272424";
    
    const ratio = value / max;
    
    if (ratio < 0.2) return "#f5c2c7"; // Very light red
    if (ratio < 0.4) return "#ea868f"; // Light red
    if (ratio < 0.6) return "#e35d6a"; // Medium red
    if (ratio < 0.8) return "#d6293c"; // Dark red
    return "#dc3545"; // Very dark red
  };

  // Function to get text color based on background
  const getTextColor = (bgColor: string) => {
    if (bgColor === "#f8f9fa" || bgColor === "#f5c2c7") return "#000";
    return "#fff";
  };

  // Calculate maximum values for color scaling
  const maxTypeValue = Math.max(
    ...(processedData.byType.length > 0 
      ? processedData.byType
          .filter(row => row.year !== "Total")
          .flatMap(row => 
            vulnerabilityTypes.map(type => row[type.name] || 0)
          )
      : [0])
  );

  const maxImpactValue = Math.max(
    ...(processedData.byImpact.length > 0 
      ? processedData.byImpact
          .filter(row => row.year !== "Total")
          .flatMap(row => 
            impactTypes.map(type => row[type.name] || 0)
          )
      : [0])
  );

  if (!fontsLoaded) {
    return null;
  }

  // Display loading state
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#FF8503" />
        <Text style={styles.loadingText}>Fetching vulnerability data...</Text>
      </View>
    );
  }

  // Display error state
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorTitle}>Error Loading Data</Text>
        <Text style={styles.errorText}>{error}</Text>
      </View>
    );
  }

  // If there's no data at all, show a message
  if (processedData.byType.length === 0 && processedData.byImpact.length === 0) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorTitle}>No Data Available</Text>
        <Text style={styles.errorText}>Unable to fetch or process vulnerability data.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Vulnerabilities by Type Table */}
      <Text style={styles.heading}>Vulnerabilities by types</Text>
      <ScrollView horizontal showsHorizontalScrollIndicator={true}>
        <View>
          <View style={styles.tableRow}>
            <View style={styles.tableHeaderCell}>
              <Text style={styles.headerText}>Year</Text>
            </View>
            {vulnerabilityTypes.map((type, index) => (
              <View key={index} style={styles.tableHeaderCell}>
                <Text style={styles.headerText}>{type.name}</Text>
              </View>
            ))}
          </View>

          {processedData.byType.map((row, rowIndex) => (
            <View key={rowIndex} style={styles.tableRow}>
              <View
                style={[
                  styles.yearCell,
                  row.year === "Total" ? styles.totalCell : null,
                ]}
              >
                <Text
                  style={[
                    styles.yearText,
                    row.year === "Total" ? styles.totalText : null,
                  ]}
                >
                  {row.year}
                </Text>
              </View>

              {vulnerabilityTypes.map((type, colIndex) => {
                const value = row[type.name] || 0;
                const bgColor =
                  row.year === "Total"
                    ? "#6722A8"
                    : getCellColor(value, maxTypeValue);
                const textColor =
                  row.year === "Total" ? "#fff" : getTextColor(bgColor);

                return (
                  <View
                    key={colIndex}
                    style={[styles.tableCell, { backgroundColor: bgColor }]}
                  >
                    <Text style={[styles.cellText, { color: textColor }]}>
                      {value}
                    </Text>
                  </View>
                );
              })}
            </View>
          ))}
        </View>
      </ScrollView>

      {/* Vulnerabilities by Impact Types Table */}
      <Text style={[styles.heading, { marginTop: 30 }]}>
        Vulnerabilities by impact types
      </Text>
      <ScrollView horizontal showsHorizontalScrollIndicator={true}>
        <View>
          <View style={styles.tableRow}>
            <View style={styles.tableHeaderCell}>
              <Text style={styles.headerText}>Year</Text>
            </View>
            {impactTypes.map((type, index) => (
              <View key={index} style={styles.tableHeaderCell}>
                <Text style={styles.headerText}>{type.name}</Text>
              </View>
            ))}
          </View>

          {processedData.byImpact.map((row, rowIndex) => (
            <View key={rowIndex} style={styles.tableRow}>
              <View
                style={[
                  styles.yearCell,
                  row.year === "Total" ? styles.totalCell : null,
                ]}
              >
                <Text
                  style={[
                    styles.yearText,
                    row.year === "Total" ? styles.totalText : null,
                  ]}
                >
                  {row.year}
                </Text>
              </View>

              {impactTypes.map((type, colIndex) => {
                const value = row[type.name] || 0;
                const bgColor =
                  row.year === "Total"
                    ? "#6722A8"
                    : getCellColor(value, maxImpactValue);
                const textColor =
                  row.year === "Total" ? "#fff" : getTextColor(bgColor);

                return (
                  <View
                    key={colIndex}
                    style={[styles.tableCell, { backgroundColor: bgColor }]}
                  >
                    <Text style={[styles.cellText, { color: textColor }]}>
                      {value}
                    </Text>
                  </View>
                );
              })}
            </View>
          ))}
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginTop: 20,
    marginBottom: 20,
    backgroundColor: "transparent",
    borderRadius: 8,
    overflow: "hidden",
    padding: 20,
  },
  loadingContainer: {
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 200,
  },
  loadingText: {
    marginTop: 15,
    fontFamily: "Inter_500Medium",
    fontSize: 16,
    color: "#eee",
  },
  errorContainer: {
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 150,
    backgroundColor: 'rgba(220, 53, 69, 0.1)',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(220, 53, 69, 0.5)',
  },
  errorTitle: {
    fontFamily: "Inter_600SemiBold",
    fontSize: 18,
    color: "#dc3545",
    marginBottom: 10,
  },
  errorText: {
    fontFamily: "Inter_500Medium",
    fontSize: 14,
    color: "#eee",
    marginBottom: 10,
    textAlign: "center",
  },
  heading: {
    fontFamily: "Inter_600SemiBold",
    fontSize: 18,
    marginBottom: 10,
    marginLeft: 5,
    color: "#eee",
  },
  tableRow: {
    flexDirection: "row",
  },
  tableHeaderCell: {
    backgroundColor: "#272424",
    padding: 10,
    width: 120,
    borderWidth: 1,
    borderColor: " rgba(39, 36, 36, 0.48)",
    alignItems: "center",
    justifyContent: "center",
  },
  headerText: {
    fontFamily: "Inter_600SemiBold",
    fontSize: 14,
    color: "#eee",
    textAlign: "center",
  },
  yearCell: {
    backgroundColor: "#272424",
    padding: 10,
    width: 120,
    borderWidth: 1,
    borderColor: " rgba(39, 36, 36, 0.48)",
    alignItems: "center",
    justifyContent: "center",
  },
  totalCell: {
    backgroundColor: "#1C1E20",
  },
  yearText: {
    fontFamily: "Inter_500Medium",
    fontSize: 14,
    color: "#FF8503",
  },
  totalText: {
    color: "#FF4203",
    fontFamily: "Inter_600SemiBold",
  },
  tableCell: {
    padding: 10,
    width: 120,
    borderWidth: 1,
    borderColor: "#111",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#111",
  },
  cellText: {
    fontFamily: "Inter_400Regular",
    fontSize: 14,
    textAlign: "center",
  },
});